package hardware

import (
	"fmt"
	"periph.io/x/conn/v3/gpio"
	"periph.io/x/conn/v3/gpio/gpioreg"
	"periph.io/x/conn/v3/spi"
	"periph.io/x/conn/v3/spi/spireg"
	"periph.io/x/host/v3"
)

const (
	DisplayWidth  = 256
	DisplayHeight = 64
)

type Display struct {
	spiPort spi.PortCloser
	spiConn spi.Conn
	dcPin   gpio.PinOut
	resPin  gpio.PinOut
	buffer  []byte
}

func NewDisplay() (*Display, error) {
	if _, err := host.Init(); err != nil {
		return nil, fmt.Errorf("failed to initialize periph: %v", err)
	}

	// Initialize SPI
	spiPort, err := spireg.Open("")
	if err != nil {
		return nil, fmt.Errorf("failed to open SPI: %v", err)
	}

	spiConn, err := spiPort.Connect(10000000, spi.Mode0, 8)
	if err != nil {
		spiPort.Close()
		return nil, fmt.Errorf("failed to connect SPI: %v", err)
	}

	// Initialize GPIO pins
	dcPin := gpioreg.ByName("GPIO25")
	if dcPin == nil {
		return nil, fmt.Errorf("failed to get DC pin")
	}
	if err := dcPin.Out(gpio.Low); err != nil {
		return nil, fmt.Errorf("failed to set DC pin: %v", err)
	}

	resPin := gpioreg.ByName("GPIO24")
	if resPin == nil {
		return nil, fmt.Errorf("failed to get RES pin")
	}
	if err := resPin.Out(gpio.High); err != nil {
		return nil, fmt.Errorf("failed to set RES pin: %v", err)
	}

	d := &Display{
		spiPort: spiPort,
		spiConn: spiConn,
		dcPin:   dcPin,
		resPin:  resPin,
		buffer:  make([]byte, DisplayWidth*DisplayHeight/2), // 4 bits per pixel for SSD1322
	}

	if err := d.init(); err != nil {
		d.Close()
		return nil, fmt.Errorf("failed to initialize display: %v", err)
	}

	return d, nil
}

func (d *Display) init() error {
	// Reset display
	d.resPin.Out(gpio.Low)
	// Small delay
	for i := 0; i < 1000; i++ {
	}
	d.resPin.Out(gpio.High)
	
	// SSD1322 initialization sequence
	initSequence := [][]byte{
		{0xFD, 0x12}, // Unlock OLED driver IC
		{0xAE},       // Display OFF
		{0xB3, 0x91}, // Display divide clockratio/oscillator frequency
		{0xCA, 0x3F}, // Multiplex ratio
		{0xA2, 0x00}, // Display offset
		{0xA1, 0x00}, // Display start line
		{0xA0, 0x14, 0x11}, // Set remap & dual COM line mode
		{0xB5, 0x00}, // GPIO
		{0xAB, 0x01}, // Function selection
		{0xB4, 0xA0, 0xB5, 0x55}, // Display enhancement
		{0xC1, 0x9F}, // Contrast current
		{0xC7, 0x0F}, // Master contrast current control
		{0xB1, 0xE2}, // Phase length
		{0xD1, 0x82, 0x20}, // Display enhancement B
		{0xBB, 0x1F}, // Precharge voltage
		{0xB6, 0x08}, // Second precharge period
		{0xBE, 0x07}, // VCOMH voltage
		{0xA6},       // Normal display
		{0xAF},       // Display ON
	}

	for _, cmd := range initSequence {
		if err := d.writeCommand(cmd); err != nil {
			return err
		}
	}

	return nil
}

func (d *Display) writeCommand(cmd []byte) error {
	d.dcPin.Out(gpio.Low) // Command mode
	return d.spiConn.Tx(cmd, nil)
}

func (d *Display) writeData(data []byte) error {
	d.dcPin.Out(gpio.High) // Data mode
	return d.spiConn.Tx(data, nil)
}

func (d *Display) Clear() {
	for i := range d.buffer {
		d.buffer[i] = 0x00
	}
}

func (d *Display) SetPixel(x, y int, brightness byte) {
	if x < 0 || x >= DisplayWidth || y < 0 || y >= DisplayHeight {
		return
	}
	
	// SSD1322 uses 4 bits per pixel, 2 pixels per byte
	bufferIndex := (y*DisplayWidth + x) / 2
	
	if x%2 == 0 {
		// Even pixel (upper nibble)
		d.buffer[bufferIndex] = (d.buffer[bufferIndex] & 0x0F) | ((brightness & 0x0F) << 4)
	} else {
		// Odd pixel (lower nibble)
		d.buffer[bufferIndex] = (d.buffer[bufferIndex] & 0xF0) | (brightness & 0x0F)
	}
}

func (d *Display) DrawText(x, y int, text string) {
	// Simple 8x8 bitmap font rendering
	for i, char := range text {
		charX := x + i*8
		if charX >= DisplayWidth {
			break
		}
		d.drawChar(charX, y, byte(char))
	}
}

func (d *Display) drawChar(x, y int, char byte) {
	// Simple font data for basic characters
	font := d.getCharBitmap(char)
	
	for row := 0; row < 8; row++ {
		for col := 0; col < 8; col++ {
			if font[row]&(1<<(7-col)) != 0 {
				d.SetPixel(x+col, y+row, 0x0F) // Full brightness
			}
		}
	}
}

func (d *Display) getCharBitmap(char byte) [8]byte {
	// Basic font bitmaps for essential characters
	switch char {
	case ' ':
		return [8]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	case '0':
		return [8]byte{0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00}
	case '1':
		return [8]byte{0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00}
	case '2':
		return [8]byte{0x3C, 0x66, 0x06, 0x0C, 0x18, 0x30, 0x7E, 0x00}
	case '3':
		return [8]byte{0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00}
	case '4':
		return [8]byte{0x0C, 0x1C, 0x2C, 0x4C, 0x7E, 0x0C, 0x0C, 0x00}
	case '5':
		return [8]byte{0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00}
	case '6':
		return [8]byte{0x1C, 0x30, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00}
	case '7':
		return [8]byte{0x7E, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00}
	case '8':
		return [8]byte{0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00}
	case '9':
		return [8]byte{0x3C, 0x66, 0x66, 0x3E, 0x06, 0x0C, 0x38, 0x00}
	case ':':
		return [8]byte{0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00}
	case '>':
		return [8]byte{0x00, 0x18, 0x30, 0x60, 0x30, 0x18, 0x00, 0x00}
	case '<':
		return [8]byte{0x00, 0x60, 0x30, 0x18, 0x30, 0x60, 0x00, 0x00}
	case 'A':
		return [8]byte{0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00}
	case 'B':
		return [8]byte{0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00}
	case 'C':
		return [8]byte{0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00}
	case 'D':
		return [8]byte{0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00}
	case 'E':
		return [8]byte{0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x7E, 0x00}
	case 'F':
		return [8]byte{0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x00}
	case 'G':
		return [8]byte{0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00}
	case 'H':
		return [8]byte{0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00}
	case 'I':
		return [8]byte{0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00}
	case 'J':
		return [8]byte{0x1E, 0x0C, 0x0C, 0x0C, 0x6C, 0x6C, 0x38, 0x00}
	case 'K':
		return [8]byte{0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00}
	case 'L':
		return [8]byte{0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00}
	case 'M':
		return [8]byte{0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00}
	case 'N':
		return [8]byte{0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00}
	case 'O':
		return [8]byte{0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00}
	case 'P':
		return [8]byte{0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00}
	case 'Q':
		return [8]byte{0x3C, 0x66, 0x66, 0x66, 0x6A, 0x6C, 0x36, 0x00}
	case 'R':
		return [8]byte{0x7C, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0x00}
	case 'S':
		return [8]byte{0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00}
	case 'T':
		return [8]byte{0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00}
	case 'U':
		return [8]byte{0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00}
	case 'V':
		return [8]byte{0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00}
	case 'W':
		return [8]byte{0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00}
	case 'X':
		return [8]byte{0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00}
	case 'Y':
		return [8]byte{0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00}
	case 'Z':
		return [8]byte{0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00}
	case 'a':
		return [8]byte{0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E, 0x00}
	case 'b':
		return [8]byte{0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x00}
	case 'c':
		return [8]byte{0x00, 0x00, 0x3C, 0x66, 0x60, 0x66, 0x3C, 0x00}
	case 'd':
		return [8]byte{0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00}
	case 'e':
		return [8]byte{0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00}
	case 'f':
		return [8]byte{0x1C, 0x36, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x00}
	case 'g':
		return [8]byte{0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x3C}
	case 'h':
		return [8]byte{0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00}
	case 'i':
		return [8]byte{0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00}
	case 'j':
		return [8]byte{0x0C, 0x00, 0x1C, 0x0C, 0x0C, 0x6C, 0x6C, 0x38}
	case 'k':
		return [8]byte{0x60, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0x00}
	case 'l':
		return [8]byte{0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00}
	case 'm':
		return [8]byte{0x00, 0x00, 0x66, 0x7F, 0x7F, 0x6B, 0x63, 0x00}
	case 'n':
		return [8]byte{0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00}
	case 'o':
		return [8]byte{0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00}
	case 'p':
		return [8]byte{0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60}
	case 'q':
		return [8]byte{0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x06}
	case 'r':
		return [8]byte{0x00, 0x00, 0x7C, 0x66, 0x60, 0x60, 0x60, 0x00}
	case 's':
		return [8]byte{0x00, 0x00, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x00}
	case 't':
		return [8]byte{0x30, 0x30, 0x7C, 0x30, 0x30, 0x36, 0x1C, 0x00}
	case 'u':
		return [8]byte{0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00}
	case 'v':
		return [8]byte{0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00}
	case 'w':
		return [8]byte{0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00}
	case 'x':
		return [8]byte{0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x00}
	case 'y':
		return [8]byte{0x00, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x3C}
	case 'z':
		return [8]byte{0x00, 0x00, 0x7E, 0x0C, 0x18, 0x30, 0x7E, 0x00}
	case '(':
		return [8]byte{0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00}
	case ')':
		return [8]byte{0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00}
	case '[':
		return [8]byte{0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00}
	case ']':
		return [8]byte{0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00}
	case '#':
		return [8]byte{0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00}
	case '-':
		return [8]byte{0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00}
	case '.':
		return [8]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00}
	case '/':
		return [8]byte{0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00}
	case '\\':
		return [8]byte{0xC0, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x02, 0x00}
	case '|':
		return [8]byte{0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00}
	case '=':
		return [8]byte{0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00}
	case '+':
		return [8]byte{0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00}
	case '?':
		return [8]byte{0x3C, 0x66, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00}
	case '!':
		return [8]byte{0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00}
	case '%':
		return [8]byte{0x62, 0x66, 0x0C, 0x18, 0x30, 0x66, 0x46, 0x00}
	default:
		return [8]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	}
}

func (d *Display) Update() error {
	// Set column address
	if err := d.writeCommand([]byte{0x15, 0x1C, 0x5B}); err != nil {
		return err
	}
	// Set row address
	if err := d.writeCommand([]byte{0x75, 0x00, 0x3F}); err != nil {
		return err
	}
	// Write RAM command
	if err := d.writeCommand([]byte{0x5C}); err != nil {
		return err
	}
	// Send buffer data
	return d.writeData(d.buffer)
}

func (d *Display) Close() error {
	if d.spiConn != nil {
		d.spiConn = nil
	}
	if d.spiPort != nil {
		return d.spiPort.Close()
	}
	return nil
}