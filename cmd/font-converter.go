package main

import (
	"flag"
	"fmt"
	"image"
	"image/draw"
	"io/ioutil"
	"log"
	"os"
	"strings"

	"golang.org/x/image/font"
	"golang.org/x/image/font/opentype"
	"golang.org/x/image/math/fixed"
)

type FontConverter struct {
	fontFace font.Face
	fontSize float64
	charSet  string
}

func main() {
	var (
		fontPath   = flag.String("font", "", "Path to TTF font file")
		fontSize   = flag.Float64("size", 12.0, "Font size in points")
		outputPath = flag.String("output", "font_data.go", "Output Go file path")
		packageName = flag.String("package", "hardware", "Go package name")
		fontName   = flag.String("name", "CustomFont", "Font variable name")
		charSet    = flag.String("charset", "", "Character set to include (default: ASCII printable)")
	)
	flag.Parse()

	if *fontPath == "" {
		log.Fatal("Font path is required. Use -font flag.")
	}

	// Default character set (ASCII printable characters)
	if *charSet == "" {
		chars := make([]byte, 0, 95)
		for i := 32; i <= 126; i++ {
			chars = append(chars, byte(i))
		}
		*charSet = string(chars)
	}

	converter, err := NewFontConverter(*fontPath, *fontSize, *charSet)
	if err != nil {
		log.Fatalf("Failed to create font converter: %v", err)
	}
	defer converter.Close()

	err = converter.GenerateGoFile(*outputPath, *packageName, *fontName)
	if err != nil {
		log.Fatalf("Failed to generate Go file: %v", err)
	}

	fmt.Printf("Font conversion complete! Generated: %s\n", *outputPath)
}

func NewFontConverter(fontPath string, fontSize float64, charSet string) (*FontConverter, error) {
	// Read font file
	fontBytes, err := ioutil.ReadFile(fontPath)
	if err != nil {
		return nil, fmt.Errorf("failed to read font file: %v", err)
	}

	// Parse TTF font
	ttfFont, err := opentype.Parse(fontBytes)
	if err != nil {
		return nil, fmt.Errorf("failed to parse font: %v", err)
	}

	// Create font face
	fontFace, err := opentype.NewFace(ttfFont, &opentype.FaceOptions{
		Size:    fontSize,
		DPI:     72,
		Hinting: font.HintingFull,
	})
	if err != nil {
		return nil, fmt.Errorf("failed to create font face: %v", err)
	}

	return &FontConverter{
		fontFace: fontFace,
		fontSize: fontSize,
		charSet:  charSet,
	}, nil
}

func (fc *FontConverter) Close() {
	if fc.fontFace != nil {
		fc.fontFace.Close()
	}
}

func (fc *FontConverter) GenerateGoFile(outputPath, packageName, fontName string) error {
	file, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("failed to create output file: %v", err)
	}
	defer file.Close()

	// Write file header
	fmt.Fprintf(file, "// Code generated by font-converter. DO NOT EDIT.\n")
	fmt.Fprintf(file, "// Font: %.1fpt\n\n", fc.fontSize)
	fmt.Fprintf(file, "package %s\n\n", packageName)

	// Get font metrics
	metrics := fc.fontFace.Metrics()
	charWidth, charHeight := fc.getMaxCharDimensions()

	fmt.Fprintf(file, "// %s contains bitmap data for the converted font\n", fontName)
	fmt.Fprintf(file, "type %sData struct {\n", fontName)
	fmt.Fprintf(file, "\tWidth  int\n")
	fmt.Fprintf(file, "\tHeight int\n")
	fmt.Fprintf(file, "\tAscent int\n")
	fmt.Fprintf(file, "\tDescent int\n")
	fmt.Fprintf(file, "\tChars map[byte][]byte\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "var %s = &%sData{\n", fontName, fontName)
	fmt.Fprintf(file, "\tWidth:  %d,\n", charWidth)
	fmt.Fprintf(file, "\tHeight: %d,\n", charHeight)
	fmt.Fprintf(file, "\tAscent: %d,\n", int(metrics.Ascent>>6))
	fmt.Fprintf(file, "\tDescent: %d,\n", int(metrics.Descent>>6))
	fmt.Fprintf(file, "\tChars: map[byte][]byte{\n")

	// Generate bitmap data for each character
	for _, char := range fc.charSet {
		bitmap, err := fc.renderCharToBitmap(byte(char), charWidth, charHeight)
		if err != nil {
			log.Printf("Warning: failed to render character '%c': %v", char, err)
			continue
		}

		fmt.Fprintf(file, "\t\t%d: { // '%c'\n", byte(char), char)
		for i, row := range bitmap {
			fmt.Fprintf(file, "\t\t\t0x%02X,", row)
			if i < len(bitmap)-1 {
				fmt.Fprintf(file, "\n")
			}
		}
		fmt.Fprintf(file, "\n\t\t},\n")
	}

	fmt.Fprintf(file, "\t},\n")
	fmt.Fprintf(file, "}\n\n")

	// Add helper methods
	fmt.Fprintf(file, "func (f *%sData) GetCharBitmap(char byte) []byte {\n", fontName)
	fmt.Fprintf(file, "\tif bitmap, exists := f.Chars[char]; exists {\n")
	fmt.Fprintf(file, "\t\treturn bitmap\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "\treturn f.Chars[32] // Return space character as fallback\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "func (f *%sData) DrawChar(display *Display, x, y int, char byte) {\n", fontName)
	fmt.Fprintf(file, "\tbitmap := f.GetCharBitmap(char)\n")
	fmt.Fprintf(file, "\tfor row := 0; row < f.Height; row++ {\n")
	fmt.Fprintf(file, "\t\tif row >= len(bitmap) {\n")
	fmt.Fprintf(file, "\t\t\tbreak\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\trowData := bitmap[row]\n")
	fmt.Fprintf(file, "\t\tfor col := 0; col < f.Width; col++ {\n")
	fmt.Fprintf(file, "\t\t\tif rowData&(1<<(7-col)) != 0 {\n")
	fmt.Fprintf(file, "\t\t\t\tdisplay.SetPixel(x+col, y+row, 0x0F)\n")
	fmt.Fprintf(file, "\t\t\t}\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n\n")

	fmt.Fprintf(file, "func (f *%sData) DrawText(display *Display, x, y int, text string) {\n", fontName)
	fmt.Fprintf(file, "\tcurrentX := x\n")
	fmt.Fprintf(file, "\tfor _, char := range text {\n")
	fmt.Fprintf(file, "\t\tif currentX >= DisplayWidth {\n")
	fmt.Fprintf(file, "\t\t\tbreak\n")
	fmt.Fprintf(file, "\t\t}\n")
	fmt.Fprintf(file, "\t\tf.DrawChar(display, currentX, y, byte(char))\n")
	fmt.Fprintf(file, "\t\tcurrentX += f.Width\n")
	fmt.Fprintf(file, "\t}\n")
	fmt.Fprintf(file, "}\n")

	return nil
}

func (fc *FontConverter) getMaxCharDimensions() (int, int) {
	maxWidth := 0
	maxHeight := 0

	for _, char := range fc.charSet {
		bounds, _ := fc.fontFace.GlyphBounds(rune(char))
		width := int((bounds.Max.X - bounds.Min.X) >> 6)  // Convert from fixed.Int26_6
		height := int((bounds.Max.Y - bounds.Min.Y) >> 6)

		if width > maxWidth {
			maxWidth = width
		}
		if height > maxHeight {
			maxHeight = height
		}
	}

	// Ensure minimum size
	if maxWidth < 8 {
		maxWidth = 8
	}
	if maxHeight < 8 {
		maxHeight = 8
	}

	return maxWidth, maxHeight
}

func (fc *FontConverter) renderCharToBitmap(char byte, width, height int) ([]byte, error) {
	// Create a small image for rendering the character
	img := image.NewGray(image.Rect(0, 0, width, height))
	
	// Clear the image (set to black)
	draw.Draw(img, img.Bounds(), &image.Uniform{image.Gray{0}}, image.Point{}, draw.Src)

	// Create drawer
	drawer := &font.Drawer{
		Dst:  img,
		Src:  &image.Uniform{image.Gray{255}}, // White text
		Face: fc.fontFace,
		Dot:  fixed.Point26_6{X: fixed.I(0), Y: fixed.I(int(fc.fontFace.Metrics().Ascent >> 6))},
	}

	// Draw the character
	drawer.DrawString(string(char))

	// Convert to bitmap
	bitmap := make([]byte, height)
	for y := 0; y < height; y++ {
		var rowByte byte
		for x := 0; x < 8 && x < width; x++ {
			if x >= width {
				break
			}
			gray := img.GrayAt(x, y)
			if gray.Y > 128 { // Threshold for black/white
				rowByte |= 1 << (7 - x)
			}
		}
		bitmap[y] = rowByte
	}

	return bitmap, nil
}